/*
 * Copyright (c) 2006 Sun Microsystems, Inc.  All rights reserved.  U.S.
 * Government Rights - Commercial software.  Government users are subject
 * to the Sun Microsystems, Inc. standard license agreement and
 * applicable provisions of the FAR and its supplements.  Use is subject
 * to license terms.
 *
 * This distribution may include materials developed by third parties.
 * Sun, Sun Microsystems, the Sun logo, Java and J2EE are trademarks
 * or registered trademarks of Sun Microsystems, Inc. in the U.S. and
 * other countries.
 *
 * Copyright (c) 2006 Sun Microsystems, Inc. Tous droits reserves.
 *
 * Droits du gouvernement americain, utilisateurs gouvernementaux - logiciel
 * commercial. Les utilisateurs gouvernementaux sont soumis au contrat de
 * licence standard de Sun Microsystems, Inc., ainsi qu'aux dispositions
 * en vigueur de la FAR (Federal Acquisition Regulations) et des
 * supplements a celles-ci.  Distribue par des licences qui en
 * restreignent l'utilisation.
 *
 * Cette distribution peut comprendre des composants developpes par des
 * tierces parties. Sun, Sun Microsystems, le logo Sun, Java et J2EE
 * sont des marques de fabrique ou des marques deposees de Sun
 * Microsystems, Inc. aux Etats-Unis et dans d'autres pays.
 */


import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.XMLFilter;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.stream.StreamResult;
import java.io.*;


public class FilterChain {
    public static void main(String[] argv) {
        if (argv.length != 3) {
            System.err.println(
                "Usage: java FilterChain stylesheet1 stylesheet2 xmlfile");
            System.exit(1);
        }

        try {
            // Read the arguments
            File stylesheet1 = new File(argv[0]);
            File stylesheet2 = new File(argv[1]);
            File datafile = new File(argv[2]);

            // Set up the input stream
            BufferedInputStream bis =
                new BufferedInputStream(new FileInputStream(datafile));
            InputSource input = new InputSource(bis);

            // Set up to read the input file
            SAXParserFactory spf = SAXParserFactory.newInstance();
            spf.setNamespaceAware(true);

            SAXParser parser = spf.newSAXParser();
            XMLReader reader = parser.getXMLReader();

            // Create the filters
            // --SAXTransformerFactory is an interface
            // --TransformerFactory is a concrete class
            // --TransformerFactory actually returns a SAXTransformerFactory instance
            // --We didn't care about that before, because we didn't use the
            // --SAXTransformerFactory extensions. But now we do, so we cast the result.
            SAXTransformerFactory stf =
                (SAXTransformerFactory) TransformerFactory.newInstance();
            XMLFilter filter1 = stf.newXMLFilter(new StreamSource(stylesheet1));
            XMLFilter filter2 = stf.newXMLFilter(new StreamSource(stylesheet2));

            // Wire the output of the reader to filter1
            // and the output of filter1 to filter2
            // --A filter is a kind of reader
            // --Setting the parent sets the input reader
            // --Since a filter is a reader, the "parent" could be another filter
            filter1.setParent(reader);
            filter2.setParent(filter1);

            // Set up the output stream
            StreamResult result = new StreamResult(System.out);

            // Set up the transformer to process the SAX events generated
            // by the last filter in the chain
            Transformer transformer = stf.newTransformer();
            SAXSource transformSource = new SAXSource(filter2, input);
            transformer.transform(transformSource, result);
        } catch (TransformerConfigurationException tce) {
            // Error generated by the parser
            System.out.println("\n** Transformer Factory error");
            System.out.println("   " + tce.getMessage());

            // Use the contained exception, if any
            Throwable x = tce;

            if (tce.getException() != null) {
                x = tce.getException();
            }

            x.printStackTrace();
        } catch (TransformerException te) {
            // Error generated by the parser
            System.out.println("\n** Transformation error");
            System.out.println("   " + te.getMessage());

            // Use the contained exception, if any
            Throwable x = te;

            if (te.getException() != null) {
                x = te.getException();
            }

            x.printStackTrace();
        } catch (SAXException sxe) {
            // Error generated by this application
            // (or a parser-initialization error)
            Exception x = sxe;

            if (sxe.getException() != null) {
                x = sxe.getException();
            }

            x.printStackTrace();
        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();
        } catch (IOException ioe) {
            // I/O error
            ioe.printStackTrace();
        }
    } // main
}
